name: Export incremental Snowflake changes
on:
 workflow_dispatch:
   inputs:
     schemas:
       description: "Space-separated schema list"
       required: true
       default: "COMETL_SFDC_CONTROL COMETL_SFDC_STAGING COMETL_SFDC_SYNC COMETL_SFDC_REPLICATION COMETL_SFDC_LANDING"
jobs:
 export:
   runs-on: ubuntu-latest
   permissions:
     contents: write
   steps:
     - name: Checkout
       uses: actions/checkout@v4
       with:
         fetch-depth: 0
     - name: Install Java (Liquibase runtime)
       uses: actions/setup-java@v4
       with:
         distribution: temurin
         java-version: "17"
     - name: Install Liquibase
       run: |
         set -euo pipefail
         LIQUIBASE_VERSION="4.29.2"
         curl -sL "https://github.com/liquibase/liquibase/releases/download/v${LIQUIBASE_VERSION}/liquibase-${LIQUIBASE_VERSION}.tar.gz" -o /tmp/liquibase.tgz
         sudo mkdir -p /opt/liquibase
         sudo tar -xzf /tmp/liquibase.tgz -C /opt/liquibase
         sudo ln -sf /opt/liquibase/liquibase /usr/local/bin/liquibase
         liquibase --version

          # âœ… FIX: Liquibase tar install does not include DB drivers. Add Snowflake JDBC + Liquibase Snowflake extension.
     - name: Install Snowflake JDBC driver + Liquibase Snowflake extension
       run: |
         set -euo pipefail
         mkdir -p lib
         # Snowflake JDBC driver (stable)
         curl -sL -o lib/snowflake-jdbc.jar \https://repo1.maven.org/maven2/net/snowflake/snowflake-jdbc/3.16.1/snowflake-jdbc-3.16.1.jar
         # Liquibase Snowflake extension - match Liquibase version
         curl -sL -o lib/liquibase-snowflake.jar \https://repo1.maven.org/maven2/org/liquibase/ext/liquibase-snowflake/4.29.2/liquibase-snowflake-4.29.2.jar
         ls -lh lib

     # Key decryption can fail for some OpenSSL v3 encrypted keys unless BouncyCastle is enabled.
     # Snowflake documents enabling it via JVM argument.  [oai_citation:3â€¡Snowflake Documentation](https://docs.snowflake.com/en/developer-guide/jdbc/jdbc-configure?utm_source=chatgpt.com)
     - name: Enable BouncyCastle for Snowflake JDBC key decryption
       run: |
         echo "JAVA_OPTS=-Dnet.snowflake.jdbc.enableBouncyCastle=true" >> $GITHUB_ENV
     # âœ… No base64. No openssl conversion. Store encrypted .p8 (PEM text) directly in secret.
     - name: Create encrypted .p8 key file from secret
       env:
         P8_PEM: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_P8_PEM }}
       run: |
         set -euo pipefail
         # printf preserves newlines exactly as stored
         printf "%s" "$P8_PEM" > snowflake_key.p8
         chmod 600 snowflake_key.p8
         echo "Key file created. Header:"
         head -n 1 snowflake_key.p8
     - name: Export incremental changes -> new branch
       env:
         SF_USER: ${{ secrets.SNOWFLAKE_USER }}
         SF_JDBC_URL: ${{ secrets.SNOWFLAKE_JDBC_URL }}   # no schema; we append it
         SF_KEY_PWD: ${{ secrets.SNOWFLAKE_PRIVATE_KEY_PASSPHRASE }}
         SCHEMAS: ${{ inputs.schemas }}
       run: |
         set -euo pipefail
         TIMESTAMP=$(date +"%Y%m%d_%H%M")
         BRANCH="db-export-${TIMESTAMP}"
         git config user.name "github-actions[bot]"
         git config user.email "github-actions[bot]@users.noreply.github.com"
         git checkout -b "$BRANCH"
         mkdir -p snowflake/snapshots
         mkdir -p snowflake/ddls snowflake/dmls snowflake/procs
         route_changes () {
           RAW="$1"
           DDL="$2"
           DML="$3"
           PROCS="$4"
           awk '
             /^--liquibase formatted sql/ {print > ddl;print > dml;print > procs;next}
             /^--changeset/              {print > ddl;print > dml;print > procs;next}
             /^--/                       {print > ddl;print > dml;print > procs;next}
             {
               line=toupper($0)
               # BLOCK DROP always
               if (line ~ /^DROP[[:space:]]+/) next
               # PROCS / FUNCTIONS
               if (line ~ /(CREATE|ALTER).* (PROCEDURE|FUNCTION)/) { print > procs; next }
               # DML
               if (line ~ /^(INSERT|UPDATE|DELETE|MERGE|COPY)[[:space:]]+/) { print > dml; next }
               # DDL (and grants)
               if (line ~ /(CREATE|ALTER|GRANT|REVOKE)/) { print > ddl; next }
               # fallback
               print > ddl
             }
           ' ddl="$DDL" dml="$DML" procs="$PROCS" "$RAW"
           for f in "$DDL" "$DML" "$PROCS"; do
             if [ ! -s "$f" ] || ! grep -Eqi "CREATE|ALTER|GRANT|REVOKE|INSERT|UPDATE|DELETE|MERGE|COPY|PROCEDURE|FUNCTION" "$f"; then
               rm -f "$f" || true
             fi
           done
         }
         for SCHEMA in $SCHEMAS; do
           echo "---- Processing schema: $SCHEMA ----"
           SNAPSHOT="snowflake/snapshots/${SCHEMA}.json"
           RAW="/tmp/${TIMESTAMP}_${SCHEMA}_raw.sql"
           # âœ… Use Snowflake JDBC parameters for encrypted private key auth:
           # private_key_file + private_key_pwd.  [oai_citation:4â€¡Snowflake Documentation](https://docs.snowflake.com/en/developer-guide/jdbc/jdbc-configure?utm_source=chatgpt.com)
           LIVE_URL="${SF_JDBC_URL}&schema=${SCHEMA}&private_key_file=$(pwd)/snowflake_key.p8&private_key_pwd=${SF_KEY_PWD}"
           # First run: baseline snapshot
           if [ ! -f "$SNAPSHOT" ]; then
             echo "Creating baseline snapshot for $SCHEMA..."
             liquibase --url="$LIVE_URL" --username="$SF_USER" \
               snapshot --snapshotFormat=json --outputFile="$SNAPSHOT"
             git add "$SNAPSHOT"
             continue
           fi
           # Reverse diff: offline snapshot (Git) vs live Snowflake DEV
           liquibase --url="offline:snowflake?snapshot=$SNAPSHOT" \
             --referenceUrl="$LIVE_URL" --referenceUsername="$SF_USER" \
             diffChangeLog --changeLogFile="$RAW"
           if [ ! -s "$RAW" ] || ! grep -Eqi "CREATE|ALTER|INSERT|UPDATE|DELETE|MERGE|COPY|PROCEDURE|FUNCTION" "$RAW"; then
             echo "No changes for $SCHEMA"
             rm -f "$RAW"
             continue
           fi
           DDL_OUT="snowflake/ddls/${TIMESTAMP}_${SCHEMA}.sql"
           DML_OUT="snowflake/dmls/${TIMESTAMP}_${SCHEMA}.sql"
           PROC_OUT="snowflake/procs/${TIMESTAMP}_${SCHEMA}.sql"
           route_changes "$RAW" "$DDL_OUT" "$DML_OUT" "$PROC_OUT"
           # Update snapshot checkpoint so next run is incremental
           liquibase --url="$LIVE_URL" --username="$SF_USER" \
             snapshot --snapshotFormat=json --outputFile="$SNAPSHOT"
           git add "$SNAPSHOT"
           [ -f "$DDL_OUT" ] && git add "$DDL_OUT"
           [ -f "$DML_OUT" ] && git add "$DML_OUT"
           [ -f "$PROC_OUT" ] && git add "$PROC_OUT"
           rm -f "$RAW"
         done
         if git diff --cached --quiet; then
           echo "Nothing to commit."
           exit 0
         fi
         git commit -m "Incremental Snowflake export (DDL+DML+PROCS) ${TIMESTAMP}"
         git push --set-upstream origin "$BRANCH"
         echo "âœ… Branch pushed: $BRANCH"
         echo "ðŸ‘‰ Manual next step: Create PR and merge to dev/qa/prod."